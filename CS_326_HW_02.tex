\documentclass[11pt]{article}

\usepackage{natbib}
\usepackage{setspace}
\usepackage[left=2.5cm,top=2.8cm,right=2.5cm,bottom=2.8cm]{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{theorem}
\usepackage{version}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage{algorithmic}
\usetikzlibrary{arrows,arrows.meta,decorations,decorations.pathreplacing,calc,matrix}

\definecolor{Red}{rgb}{1,0,0}
\definecolor{Blue}{rgb}{0,0,1}
\definecolor{Green}{rgb}{0,1,0}
\definecolor{magenta}{rgb}{1,0,.6}
\definecolor{lightblue}{rgb}{0,.5,1}
\definecolor{lightpurple}{rgb}{.6,.4,1}
\definecolor{gold}{rgb}{.6,.5,0}
\definecolor{orange}{rgb}{1,0.4,0}
\definecolor{hotpink}{rgb}{1,0,0.5}
\definecolor{newcolor2}{rgb}{.5,.3,.5}
\definecolor{newcolor}{rgb}{0,.3,1}
\definecolor{newcolor3}{rgb}{1,0,.35}
\definecolor{darkgreen1}{rgb}{0, .35, 0}
\definecolor{darkgreen}{rgb}{0, .6, 0}
\definecolor{darkred}{rgb}{.75,0,0}
\definecolor{lightgrey}{rgb}{.7,.7,.7}

\definecolor{clemson-orange}{RGB}{234,106,32}
\definecolor{chicago-maroon}{RGB}{128,0,0}
\definecolor{northwestern-purple}{RGB}{82,0,99}
\definecolor{cornell-red}{RGB}{179,27,27}
\definecolor{sauder-green}{RGB}{171,180,0}
%\definecolor{gray}{RGB}{192,192,192}
\definecolor{lawngreen}{RGB}{0,250,154}

\setcounter{MaxMatrixCols}{10}

\onehalfspacing
\newtheorem{theorem}{Theorem}
\newtheorem{acknowledgement}{Acknowledgement}
\newtheorem{algorithm}{Algorithm}
\newtheorem{assumption}{Assumption}
\newtheorem{axiom}{Axiom}
\newtheorem{case}{Case}
\newtheorem{claim}{Claim}
\newtheorem{conclusion}{Conclusion}
\newtheorem{condition}{Condition}
\newtheorem{conjecture}{Conjecture}
\newtheorem{corollary}{Corollary}
\newtheorem{criterion}{Criterion}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{exercise}{Exercise}
\newtheorem{lemma}{Lemma}
\newtheorem{notation}{Notation}
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}
{\theorembodyfont{\normalfont}
\newtheorem{remark}{Remark}
}
\newtheorem{summary}{Summary}
\newenvironment{proof}[1][Proof]{\textbf{#1.} }{\hfill \rule{0.5em}{0.5em} \bigskip}
\newenvironment{soln}[1][Soln]{\textbf{#1:} }{\hfill \rule{0.5em}{0.5em}}
\renewcommand{\cite}{\citeasnoun}
\renewcommand{\theenumii}{(\alph{enumii})}
\renewcommand{\labelenumii}{\theenumii}
\renewcommand{\theenumiii}{\roman{enumiii}}
\renewcommand{\labelenumiii}{\theenumiii.}

\usepackage[nameinlink]{cleveref}
\crefname{assumption}{Assumption}{Assumptions}
\crefname{lemma}{Lemma}{Lemmas}
\crefname{theorem}{Theorem}{Theorems}
\crefname{corollary}{Corollary}{Corollaries}
\crefname{proposition}{Proposition}{Propositions}
\crefname{claim}{Claim}{Claims}
\crefname{procedure}{Procedure}{Procedures}
\crefname{algorithm}{Algorithm}{Algorithms}
\crefname{figure}{Figure}{Figures}
\crefname{remark}{Remark}{Remarks}
\crefname{section}{Section}{Sections}
\crefname{procedure}{Procedure}{Procedures}
\crefname{example}{Example}{Examples}
\crefname{definition}{Definition}{Definitions}
\crefname{table}{Table}{Tables}
\crefname{align}{}{}
\crefname{enumi}{}{}
\crefname{conjecture}{Conjecture}{Conjectures}
\crefname{step}{Step}{Steps}
\crefname{appendix}{Appendix}{Appendices}
\crefname{footnote}{Footnote}{Footnotes}

\begin{document}


\begin{center}
    \textbf{CS 326 - Analysis of Algorithms - HW 2}\\
\end{center}


\begin{flushleft}
    \textit{Prof. M. Grigni\hfill09/22/2022 \hfill Hridansh Saraogi} \\
    \vspace{0.15cm}
    \small {Help taken from: Prof. Grigni, and Zhenke Liu}
\end{flushleft}


\begin{enumerate}

\item Problem 1. Shifted Recurrence. \\
For positive integers n, define T(n) using this recurrence:
\begin{equation}
T(n) = 
\left\{
    \begin{array}{lr}
        n & \text{for }  1 \leq n \leq 10,\\
        2*(T( \lfloor n/2 \rfloor + 5)+n, & \text{for } n\geq 11.
    \end{array}
\right\}
\end{equation}
Our goal is to show $T(n) = O(n*lg n)$, without using the Master Theorem. (This resembles the mergesort recurrence, except for the "+5" shifting term. In this problem we show that we get the same asymptotic upper bound.)

    \begin{enumerate}
        \item Argue that $T(n)$ is non-decreasing. That is, $T(n) \leq T(n+1)$ for all $n \geq 1$. Use induction.

        \item Find constants c and d, so that $T(2^k+10) \leq 2^k(k+c)-d$ for all integers $k \geq 10$. Use induction on k, and give explicit values for c and d.

        \item Using (a) and (b), conclude that T(n) is $O(n* lg n)$.
        
    \end{enumerate}

\item Problem 2. Selection in Two Sorted Arrays.\\
Suppose A[1..m] and B[1..n] are two sorted arrays of numbers, and that the m+n numbers are all distinct. We are also given an integer i, $1 \leq i \leq m+n$. We want to return the $i^{th}$ smallest number, in the union of A and B. Like in Chapter 9: i=1 means we should return the minimum, i=m+n means we should return the maximum. Using pseudocode, write out a procedure solving this problem, and argue that it runs in O(lg(m+n)) time.  Your solving procedure may be recursive, and it probably works on subarrays of the original arrays, for example: solve(A,p1, r1, B, p2, r2, i).\vspace{0.1cm}

\textbf{Hints: }If m or n is zero, the problem is easy. While both arrays are nonempty, compare the median of A with the median of B. Then depending on the comparison and i, you have enough information to eliminate either half of A or half of B.\\



\item Problem 3. LCS Backtracking.\\
(Based on Exercise 15.4-2, page 396.) Write a pseudo-code procedure PRINT$-LCS(c,X,Y,i,j)$, similar to PRINT$-LCS(b,X,i,j)$ on page 395. Its initial call is PRINT$-LCS(c,X,Y,m,n)$, where m=X.length and n=Y.length. It should produce exactly the same output, using the "c" array but not the "b" array. It should still run in $O(m+n)$ time.


\item Problem 4. Optimal BST Example.\\
Do Exercise 15.5-2. Show the e[i,j] table (a triangular table of numbers) and draw an optimal tree.\vspace{0.1cm}

\textbf{Hints: }the table is hard to compute by hand, I recommend writing a small program to help yourself.

\item Problem 5. Reality Check.

        \\
        \textbf{NOTE: }this problem involves writing a short program (in your favorite language). Do not collaborate on the program code, write your own! You may either embed the program in your main PDF, or you may submit it as a separate file. Either way, remember to include a CS "SPCA" comment near the top of your program.\\ \\
        Consider these recurrences, defining M(n) and S(n) for all integers $n \geq 0$:
                
        \begin{equation}
        M(n) = 
        \left\{
            \begin{array}{lr}
                0 & \text{if }  n \leq 1,\\
                M(\lfloor n/2 \rfloor) + M( \lfloor n/2 \rfloor)+n-1 & \text{otherwise}.
            \end{array}
        \right\}
        \end{equation}     
        
        \begin{equation}
        S(n) = 
        \left\{
            \begin{array}{lr}
                M(n) & \text{if }  n < 140,\\
                6*\lfloor n/5 \rfloor) + S( \lfloor n/5 \rfloor)+ S(6 + \lfloor 7n/10 \rfloor) & \text{otherwise}.
            \end{array}
        \right\}
        \end{equation}  
        
        M(n) is the worst-case number of comparisons used by Merge-Sort on n items, and S(n) is (roughly) the worst case number of comparisons used by Select on n items (see Section 9.3). From the book we know that $M(n)=Θ(n*lg n)$ and $S(n)=Θ(n)$, so eventually S(n) is much smaller than M(n).\\ \\
        Write a computer program finding the first n such that $2*S(n) < M(n)$. It should print n, S(n), and M(n). Turn in a copy of your program, and its output.
        \\ \\
        \textit{Remarks: }the first n with $S(n)<M(n)$ is n=154, with $S(n)=974$ and $M(n)=977$. This exercise illustrates that Select does not have much advantage for small inputs (you should probably just sort). The first "6" is the S(n) recurrence is because we can find the median of 5 items using only 6 comparisons (a fun puzzle, but you don't have to solve it).




\end{enumerate}

\end{document}

